import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import sqrtm, inv

def construct_K_matrix_circles(num_layers, k, alpha, c=1.0):
    """
    Constructs the spring constant matrix K using K = D - A + cI for a system of harmonic oscillators in concentric circles.
    :param num_layers: Number of concentric layers (circles)
    :param k: Spring constant for nearest-neighbor interactions
    :param alpha: On-site potential coefficient
    :param c: Shift constant for ensuring positive definiteness
    :return: NxN Spring constant matrix K, node positions, and layer indices
    """
    layer_sizes = [6 * i for i in range(1, num_layers + 1)]
    N = sum(layer_sizes)
    A = np.zeros((N, N))  # Adjacency matrix
    D = np.zeros((N, N))  # Degree matrix
    positions = []
    layer_indices = []
    
    start_idx = 0
    for layer, size in enumerate(layer_sizes):
        radius = layer + 1
        theta_step = 2 * np.pi / size
        layer_indices.append(list(range(start_idx, start_idx + size)))
        for i in range(size):
            theta = i * theta_step
            positions.append((radius * np.cos(theta), radius * np.sin(theta)))
        start_idx += size
    
    for layer in layer_indices:
        size = len(layer)
        for i in range(size):
            j = (i + 1) % size
            A[layer[i], layer[j]] = A[layer[j], layer[i]] = -k
            D[layer[i], layer[i]] += k
            D[layer[j], layer[j]] += k
    
    for l in range(len(layer_indices) - 1):
        inner_layer = layer_indices[l]
        outer_layer = layer_indices[l + 1]
        for i in range(len(inner_layer)):
            for j in range(6):
                outer_idx = (i * 6 + j) % len(outer_layer)
                A[inner_layer[i], outer_layer[outer_idx]] = A[outer_layer[outer_idx], inner_layer[i]] = -k
                D[inner_layer[i], inner_layer[i]] += k
                D[outer_layer[outer_idx], outer_layer[outer_idx]] += k
    
    K = D - A + c * np.eye(N)  # Construct K matrix
    return K, positions, layer_indices

def compute_gamma_matrix(K):
    return sqrtm(inv(K))

def compute_correlation(Gamma, site_i, site_j):
    return 0.5 * Gamma[site_i, site_j]

def update_gamma_after_momentum_measurement(Gamma, B_indices, measurement_outcome):
    A_indices = [i for i in range(Gamma.shape[0]) if i not in B_indices]
    Gamma_AA = Gamma[np.ix_(A_indices, A_indices)]
    Gamma_AB = Gamma[np.ix_(A_indices, B_indices)]
    Gamma_BB = Gamma[np.ix_(B_indices, B_indices)]
    Gamma_BA = Gamma_AB.T
    Gamma_AA_updated = Gamma_AA - Gamma_AB @ np.linalg.inv(Gamma_BB) @ Gamma_BA
    shift_p_A = -Gamma_AB @ np.linalg.inv(Gamma_BB) @ measurement_outcome
    return Gamma_AA_updated, shift_p_A, A_indices

def plot_updated_system(positions, updated_A_indices, B_indices, correlation_sites):
    fig, ax = plt.subplots(figsize=(6, 6))
    for i, pos in enumerate(positions):
        if i in B_indices:
            ax.scatter(*pos, color='green', s=50)  # Measured bulk sites
        elif i in updated_A_indices:
            ax.scatter(*pos, color='red', s=50)  # Remaining boundary
        if i in correlation_sites:
            ax.scatter(*pos, color='orange', marker='s', s=80)  # Correlation sites
        ax.text(pos[0], pos[1], str(i), fontsize=8, ha='center')
    ax.set_aspect('equal')
    plt.title("System After Measurement")
    plt.show()

# Example usage:
if __name__ == "__main__":
    num_layers = 9
    k = 1.0
    alpha = 0.5
    c = 1.0
    
    K, positions, layer_indices = construct_K_matrix_circles(num_layers, k, alpha, c)
    Gamma = compute_gamma_matrix(K)
    
    B_indices = [i for layer in layer_indices[:-1] for i in layer]
    A_indices = layer_indices[-1]
    #selected_correlation_sites = np.random.choice(A_indices, size=2, replace=False).tolist()
    selected_correlation_sites = [266,257]
    
    correlation_before = compute_correlation(Gamma, selected_correlation_sites[0], selected_correlation_sites[1])
    
    momentum_measurement_outcome = np.random.multivariate_normal(
        mean=np.zeros(len(B_indices)), 
        cov=Gamma[np.ix_(B_indices, B_indices)]
    )
    
    Gamma_AA_mom_updated, shift_p_A, updated_A_indices = update_gamma_after_momentum_measurement(Gamma, B_indices, momentum_measurement_outcome)
    
    updated_correlation_sites = [updated_A_indices.index(site) for site in selected_correlation_sites if site in updated_A_indices]
    if len(updated_correlation_sites) == 2:
        correlation_after = compute_correlation(Gamma_AA_mom_updated, updated_correlation_sites[0], updated_correlation_sites[1])
    else:
        correlation_after = None  # If one of the selected sites is no longer in the system
    
    plot_updated_system(positions, updated_A_indices, B_indices, selected_correlation_sites)
    
    print(f"Correlation between sites {selected_correlation_sites} before measurement: {correlation_before}")
    if correlation_after is not None:
        print(f"Correlation between sites {selected_correlation_sites} after measurement: {correlation_after}")
    else:
        print(f"One of the selected sites was removed after measurement, so correlation cannot be computed.")
